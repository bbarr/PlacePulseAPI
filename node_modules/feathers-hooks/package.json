{
  "name": "feathers-hooks",
  "version": "0.4.0",
  "description": "Before and after service method call hooks for easy authorization and processing.",
  "homepage": "https://github.com/feathersjs/feathers-hooks",
  "keywords": [
    "feathers-plugin",
    "feathers"
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/feathersjs/feathers-hooks/blob/master/LICENSE"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/feathersjs/feathers-hooks.git"
  },
  "author": {
    "name": "David Luecke",
    "email": "daff@neyeon.com",
    "url": "https://feathersjs.com"
  },
  "contributors": [],
  "bugs": {
    "url": "https://github.com/feathersjs/feathers-hooks/issues"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "main": "lib/hooks.js",
  "scripts": {
    "test": "grunt test"
  },
  "directories": {
    "lib": "lib"
  },
  "dependencies": {
    "lodash": "^2.4.1"
  },
  "devDependencies": {
    "feathers": "1.0.0-pre.1",
    "grunt": "~0.4.1",
    "grunt-cli": "~0.1.7",
    "grunt-contrib-jshint": "~0.x",
    "grunt-contrib-watch": "~0.5.3",
    "grunt-release": "~0.5.1",
    "grunt-simple-mocha": "~0.4.0",
    "mocha": "*",
    "q": "^1.0.1"
  },
  "peerDependencies": {
    "feathers": ">= 0.3.0"
  },
  "readme": "# Feathers Hooks\n\n[![Build Status](https://travis-ci.org/feathersjs/feathers-hooks.png?branch=master)](https://travis-ci.org/feathersjs/feathers-hooks)\n\n> Before and after service method call hooks for easy authorization and processing.\n\n## Getting Started\n\nTo install feathers-hooks from [npm](https://www.npmjs.org/), run:\n\n```bash\n$ npm install feathers-hooks --save\n```\n\nFinally, to use the plugin in your Feathers app:\n\n```javascript\nvar feathers = require('feathers');\nvar hooks = require('feathers-hooks');\n\nvar app = feathers().configure(hooks());\n```\n\n## Examples\n\nThe repository contains the following working examples:\n\n- [authorization.js](https://github.com/feathersjs/feathers-hooks/blob/master/examples/authorization.js) - A simple demo showing how to use hooks for authorization (and post-processing the results) where the user is set via a ?user=username query parameter.\n- [timestamp.js](https://github.com/feathersjs/feathers-hooks/blob/master/examples/timestamp.js) - A demo that adds a `createdAt` and `updatedAt` timestamp when creating or updating a Todo using hooks.\n\n## Using hooks\n\nFeathers hooks are a form of [Aspect Oriented Programming](http://en.wikipedia.org/wiki/Aspect-oriented_programming) that allow you to decouple things like authorization and pre- or post processing from your services logic.\n\nYou can add as many `before` and `after` hooks to any Feathers service method as you want (they will be executed in the order they have been registered). There are two ways to use hooks. Either after registering the service by calling `service.before(beforeHooks)` or `service.after(afterHooks)` or by adding a `before` or `after` object with your hooks to the service.\n\nLets assume a Feathers application initialized like this:\n\n```js\nvar feathers = require('feathers');\nvar hooks = require('feathers-hooks');\n\nvar app = feathers()\n    .configure(hooks())\n    .use('/todos', {\n       todos: [],\n\n       get: function(id, params, callback) {\n         for(var i = 0; i < this.todos.length; i++) {\n          if(this.todos[i].id === id) {\n            return callback(null, this.todos[i]);\n          }\n         }\n\n         callback(new Error('Todo not found'));\n       },\n\n       // Return all todos from this service\n       find: function(params, callback) {\n         callback(null, this.todos);\n       },\n\n       // Create a new Todo with the given data\n       create: function(data, params, callback) {\n         data.id = this.todos.length;\n         this.todos.push(data);\n\n         callback(null, data);\n       }\n     });\n\napp.listen(8000);\n\n// Get the wrapped service object which will be used in the other exapmles\nvar todoService = app.lookup('todos');\n```\n\n### `service.before(beforeHooks)`\n\n`before` hooks allow you to pre-process service call parameters. They will be called with the hook object\nand a callback which should be called with any errors or no arguments or `null` and the modified hook object.\nThe hook object contains information about the intercepted method and for `before` hooks can have the following properties:\n\n- __method__ - The method name\n- __type__ - The hook type (`before` or `after`)\n- __callback__ - The original callback (can be replaced but shouldn't be called in your hook)\n- __params__ - The service method parameters\n- __data__ - The request data (for `create`, `update` and `patch`)\n- __id__ - The id (for `get`, `remove`, `update` and `patch`)\n\nAll properties of the hook object can be modified and the modified data will be used for the actual service method\ncall. This is very helpful for pre-processing parameters and massaging data when creating or updating.\n\nThe following example checks if a user has been passed to the services `find` method and returns an error if not\nand also adds a `createdAt` property to a newly created todo:\n\n```js\ntodoService.before({\n  find: function (hook, next) {\n    if (!hook.params.user) {\n      return next(new Error('You are not logged in'));\n    }\n    \n    next();\n  },\n\n  create: function(hook, next) {\n    hook.data.createdAt = new Date();\n\n    next();\n    // Or\n    next(null, hook);\n  }\n});\n```\n\n### `service.after(afterHooks)`\n\n`after` hooks will be called with a similar hook object than `before` hooks but additionally contain a `result`\nproperty with the service call results:\n\n- __method__ - The method name\n- __type__ - The hook type (`before` or `after`)\n- __result__ - The service call result data\n- __callback__ - The original callback (can be replaced but shouldn't be called in your hook)\n- __params__ - The service method parameters\n- __data__ - The request data (for `create`, `update` and `patch`)\n- __id__ - The id (for `get`, `remove`, `update` and `patch`)\n\nIn any `after` hook, only modifications to the `result` object will have any effect. This is a good place to filter or\npost-process the data retrieved by a service and also add some additional authorization that needs the actual data.\n\nThe following example filters the data returned by a `find` service call based on a users company id\nand checks if the current user is allowed to retrieve the data returned by `get` (that is, they have the same company id):\n\n```js\ntodoService.after({\n  find: function (hook, next) {\n    // Manually filter the find results\n    hook.result = _.filter(hook.result, function (current) {\n      return current.companyId === params.user.companyId;\n    });\n\n    next();\n  },\n\n  get: function (hook, next) {\n    if (hook.result.companyId !== hook.params.user.companyId) {\n      return next(new Error('You are not authorized to access this information'));\n    }\n\n    next();\n  }\n});\n```\n\n### As service properties\n\nYou can also add `before` and `after` hooks to your initial service object right away by setting the `before` and\n`after` properties to the hook object. The following example has the same effect as the previous examples:\n\n```js\nvar TodoService = {\n\ttodos: [],\n\n\tget: function (id, params, callback) {\n\t\tfor (var i = 0; i < this.todos.length; i++) {\n\t\t\tif (this.todos[i].id === id) {\n\t\t\t\treturn callback(null, this.todos[i]);\n\t\t\t}\n\t\t}\n\n\t\tcallback(new Error('Todo not found'));\n\t},\n\n\t// Return all todos from this service\n\tfind: function (params, callback) {\n\t\tcallback(null, this.todos);\n\t},\n\n\t// Create a new Todo with the given data\n\tcreate: function (data, params, callback) {\n\t\tdata.id = this.todos.length;\n\t\tthis.todos.push(data);\n\n\t\tcallback(null, data);\n\t},\n\n\tbefore: {\n\t\tfind: function (hook, next) {\n\t\t\tif (!hook.params.user) {\n\t\t\t\treturn next(new Error('You are not logged in'));\n\t\t\t}\n\n\t\t\tnext();\n\t\t},\n\n\t\tcreate: function (hook, next) {\n\t\t\thook.data.createdAt = new Date();\n\n\t\t\tnext();\n\t\t\t// Or\n\t\t\tnext(null, hook);\n\t\t}\n\t},\n\n\tafter: {\n\t\tfind: function (hook, next) {\n\t\t\t// Manually filter the find results\n\t\t\thook.result = _.filter(hook.result, function (current) {\n\t\t\t\treturn current.companyId === params.user.companyId;\n\t\t\t});\n\n\t\t\tnext();\n\t\t},\n\n\t\tget: function (hook, next) {\n\t\t\tif (hook.result.companyId !== hook.params.user.companyId) {\n\t\t\t\treturn next(new Error('You are not authorized to access this information'));\n\t\t\t}\n\n\t\t\tnext();\n\t\t}\n\t}\n}\n```\n\n### Promises\n\nAll hooks can return a [Promise](http://promises-aplus.github.io/promises-spec/) object instead of calling the callback. The promises return value will *not* be used. Using [Q](https://github.com/kriskowal/q) it would look like:\n\n```js\ntodoService.before({\n  find: function (hook) {\n    return Q(/* ... */);\n  }\n});\n```\n\nIf you want to change the hook object just chain the returned promise using `.then`:\n\n```js\ntodoService.before({\n  find: function (hook) {\n    return Q(/* ... */).then(function(result) {\n      hook.params.message = 'Ran through promise hook';\n      hook.data.result = result;\n    });\n  }\n});\n```\n\nIf a promise fails, the error will be propagated immediately.\n\n### Chaining / Registering Multiple Hooks\n\nIf you want to register more than one `before` or `after` hook for the same method, there are 2 ways that you can do this:\n\n#### Dynamic Registrations\n\nIf you register a `before` or `after` hook for a certain method in one place and then register another `before` or `after` hook for the same method, `feathers-hooks` will automatically execute them in a chained fashion **in the order that they were registered**.\n\n> **Pro Tip:** _This works well if you have more dynamic or conditional hooks._\n\n```js\nvar app = feathers().use('/users', userService);\n\n// We need to retrieve the wrapped service object from app which has the added hook functionality\nvar userService = app.lookup('users');\n\nuserService.before({\n    ...\n});\n\n// Somewhere else\nuserService.before({\n    ...\n});\n\n```\n\n#### Defining Arrays\n\nYou can also register multiple hooks at the same time, in the order that you want them executed, when you are registering your service.\n\n> **Pro Tip:** _This is the preferred method becuase it is bit cleaner and execution order is more apparent._\n\n\n```js\nvar hooks = require('your-hooks');\n\nvar app = feathers().use('/users', userService);\n\n// We need to retrieve the wrapped service object from app which has the added hook functionality\nvar userService = app.lookup('users');\n\nuserService.before({\n  // Auth is required.  No exceptions\n  create : [hooks.requireAuth, hooks.setUserID, hooks.setCreatedAt]\n});\n\n```\n\n## Changelog\n\n__0.4.0__\n\n- Allows hooks to be chained in an array ([#2](https://github.com/feathersjs/feathers-hooks/issues/2))\n\n__0.3.0__\n\n- Allows hooks to return a promise ([#3](https://github.com/feathersjs/feathers-hooks/issues/3), [#4](https://github.com/feathersjs/feathers-hooks/issues/4))\n\n__0.2.0__\n\n- API change to use hook objects instead of function parameters ([#1](https://github.com/feathersjs/feathers-hooks/issues/1))\n\n__0.1.0__\n\n- Initial release\n\n## Author\n\n- [David Luecke](https://github.com/daffl)\n\n## License\n\nCopyright (c) 2014 David Luecke\n\nLicensed under the [MIT license](LICENSE).\n",
  "readmeFilename": "README.md",
  "_id": "feathers-hooks@0.4.0",
  "dist": {
    "shasum": "e85c5abe0fe777f8a25165d4af28e6ab497add93"
  },
  "_resolved": "git://github.com/feathersjs/feathers-hooks.git#ee2e09b9e539716d2e5aea415f7b789fc1b2d3c9",
  "_from": "git://github.com/feathersjs/feathers-hooks.git"
}
